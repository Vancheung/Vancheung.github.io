<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://vancheung.github.io//</id><title>Van 写字的地方</title><subtitle>测试, 测开, python, devops, 读书.</subtitle> <updated>2021-09-08T09:59:37+08:00</updated> <author> <name>vancheung</name> <uri>https://vancheung.github.io//</uri> </author><link rel="self" type="application/atom+xml" href="https://vancheung.github.io//feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://vancheung.github.io//"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 vancheung </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title></title><link href="https://vancheung.github.io//posts/2021-09-07-Python%E8%BF%9B%E9%98%B6-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84Python%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/" rel="alternate" type="text/html" title="" /><published>2021-09-08T09:59:37+08:00</published> <updated>2021-09-08T09:59:37+08:00</updated> <id>https://vancheung.github.io//posts/2021-09-07-Python%E8%BF%9B%E9%98%B6-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84Python%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/</id> <content src="https://vancheung.github.io//posts/2021-09-07-Python%E8%BF%9B%E9%98%B6-UI%E8%87%AA%E5%8A%A8%E5%8C%96%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E7%9A%84Python%E8%BF%9B%E9%98%B6%E7%89%B9%E6%80%A7/" /> <author> <name>vancheung</name> </author> <summary> 一、抽象类 在实现UI自动化框架时，存在一个常见的情况，Android和iOS封装相同的接口，从而实现用例的一致性，如下是一个简单的示例： class AndroidClient: def open_app(self): # some code class IosClient: def open_app(self): # some code if __name__ == "__main__": if platform=="android": client = AndroidClient() else: client = IosClient() client.open_app() 下文根据这两个示例类进行讲解。 1、继承 当AndroidClient和... </summary> </entry> <entry><title>【Day 6】关于我是如何干掉Appium和RobotFramework这件事的——使用sphinx自动生成API文档</title><link href="https://vancheung.github.io//posts/Day-6-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/" rel="alternate" type="text/html" title="【Day 6】关于我是如何干掉Appium和RobotFramework这件事的——使用sphinx自动生成API文档" /><published>2021-08-02T17:00:00+08:00</published> <updated>2021-08-02T17:00:00+08:00</updated> <id>https://vancheung.github.io//posts/Day-6-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/</id> <content src="https://vancheung.github.io//posts/Day-6-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90API%E6%96%87%E6%A1%A3/" /> <author> <name>vancheung</name> </author> <category term="客户端自动化" /> <category term="框架设计" /> <summary> 一、安装sphinx 1、创建新项目 pip install sphinx mkdir doc cd doc/ sphinx-quickstart &amp;gt; Separate source and build directories (y/n) [n]: y &amp;gt; Project name: ClientEngine &amp;gt; Author name(s): Van &amp;gt; Project release []: &amp;gt; Project language [en]: zh_CN 2、编译html文件 sphinx-build -b html ./source ./build # 清理编译结果 make clean 打开./doc/build/index.html： 二、修改主题 1、安装sphinx_rtd_theme pip install sp... </summary> </entry> <entry><title>【Day 5】关于我是如何干掉Appium和RobotFramework这件事的——python-wda查找速度优化</title><link href="https://vancheung.github.io//posts/Day-5-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-python-wda%E6%9F%A5%E6%89%BE%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" rel="alternate" type="text/html" title="【Day 5】关于我是如何干掉Appium和RobotFramework这件事的——python-wda查找速度优化" /><published>2021-07-08T18:00:00+08:00</published> <updated>2021-08-10T18:42:34+08:00</updated> <id>https://vancheung.github.io//posts/Day-5-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-python-wda%E6%9F%A5%E6%89%BE%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</id> <content src="https://vancheung.github.io//posts/Day-5-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-python-wda%E6%9F%A5%E6%89%BE%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/" /> <author> <name>vancheung</name> </author> <category term="客户端自动化" /> <category term="框架设计" /> <summary> 一、一次定位操作背后发生了什么 # 初始化wda_client import wda wda_client = wda.Client() # 调用查找元素 self.wda_client(label='登录') 这个行为会调用BaseClient类的__call__方法，返回一个Selector对象 class BaseClient(object) def __init__(self, url=None, _session_id=None): self.__timeout = 30.0 def __call__(self, *args, **kwargs): if 'timeout' not in kwargs: kwargs['timeout'] = self.__timeout... </summary> </entry> <entry><title>【Day 4】关于我是如何干掉Appium和RobotFramework这件事的——PO有向图</title><link href="https://vancheung.github.io//posts/Day-4-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-PO%E6%9C%89%E5%90%91%E5%9B%BE/" rel="alternate" type="text/html" title="【Day 4】关于我是如何干掉Appium和RobotFramework这件事的——PO有向图" /><published>2021-06-28T18:00:00+08:00</published> <updated>2021-06-29T17:28:40+08:00</updated> <id>https://vancheung.github.io//posts/Day-4-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-PO%E6%9C%89%E5%90%91%E5%9B%BE/</id> <content src="https://vancheung.github.io//posts/Day-4-%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E5%A6%82%E4%BD%95%E5%B9%B2%E6%8E%89Appium%E5%92%8CRobotFramework%E8%BF%99%E4%BB%B6%E4%BA%8B%E7%9A%84-PO%E6%9C%89%E5%90%91%E5%9B%BE/" /> <author> <name>vancheung</name> </author> <category term="客户端自动化" /> <category term="框架设计" /> <summary> 一、问题背景 先写一个简单的登录Action class UiClient: def __init__(self): self.client = wda.client() def login(self,username,password): self.client.input(帐号输入框, username) self.client.input(密码输入框, password) self.client.click(登录) if __name__ == '__main__': ui = UiClient() ui.login('张三', 123456) 这样的登录操作其实隐含了一个前提：当前已经在登录页。 而在实际测试过程中，没办法保证前一次测试的环境清理成功完成，因此也引入了... </summary> </entry> <entry><title>【Python基础】为什么pip安装过的库，在import的时候还是报错——Python虚拟环境介绍</title><link href="https://vancheung.github.io//posts/Python%E5%9F%BA%E7%A1%80-%E4%B8%BA%E4%BB%80%E4%B9%88pip%E5%AE%89%E8%A3%85%E8%BF%87%E7%9A%84%E5%BA%93-%E5%9C%A8import%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%98%E6%98%AF%E6%8A%A5%E9%94%99-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/" rel="alternate" type="text/html" title="【Python基础】为什么pip安装过的库，在import的时候还是报错——Python虚拟环境介绍" /><published>2021-06-18T14:00:00+08:00</published> <updated>2021-06-18T14:00:00+08:00</updated> <id>https://vancheung.github.io//posts/Python%E5%9F%BA%E7%A1%80-%E4%B8%BA%E4%BB%80%E4%B9%88pip%E5%AE%89%E8%A3%85%E8%BF%87%E7%9A%84%E5%BA%93-%E5%9C%A8import%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%98%E6%98%AF%E6%8A%A5%E9%94%99-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/</id> <content src="https://vancheung.github.io//posts/Python%E5%9F%BA%E7%A1%80-%E4%B8%BA%E4%BB%80%E4%B9%88pip%E5%AE%89%E8%A3%85%E8%BF%87%E7%9A%84%E5%BA%93-%E5%9C%A8import%E7%9A%84%E6%97%B6%E5%80%99%E8%BF%98%E6%98%AF%E6%8A%A5%E9%94%99-Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E4%BB%8B%E7%BB%8D/" /> <author> <name>vancheung</name> </author> <category term="Python编程" /> <category term="Python基础" /> <summary> 【问题描述】 最近收到一些同事们的疑问，为什么使用pip安装后的库，在PyCharm导入的时候还是会报 ModuleNotFoundError: No module named ‘xxx’ 如果只想简单粗暴的解决问题，以下方法二选一： （1）在当前项目下打开Terminal窗口，重新pip安装一次对应的库 （2）在Preferences中修改当前项目的Python Interpreter为系统的python路径 但知其然在此处，还是总结一下为什么会出现这种问题，以及如何选择更合适自己的解决方法。 【原理详解】 1、解释器（Interpreter） Python是一门解释型语言，不需要编译和链接，代码在运行时通过解释器来翻译成机器语言执行。 因此，从cmd或Terminal窗口输入python（已配置环境变量）、运行可执行文件python（如python.... </summary> </entry> </feed>
